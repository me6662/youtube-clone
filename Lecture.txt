///////////////////////// npm 초기 사용 /////////////////////////////////

 node js 설치 시, npm 도 같이 설치된다.

* npm init : npm 에서 제공하는 프로젝트 initalize  >> package.json 파일을 작성됨.

* npm install express : express 모듈 설치

* git ignore 파일 만들어서 node_modules 및 package-lock 를 ignore (왜냐면 굳이 무거운 파일을 안올려도됨)  
>> 다른 컴퓨터에서 써도 npm install 하면 dependencies 보고 자동으로 다운받음 (packages.json 에 있다.)

///////////////////// Git 에 변경사항 발행하기 ////////////////////////////////////

* git remote add origin <repo 주소> : git clone 이라고 원격저장소 (인터넷에있는 저장소) 를 불러와서 origin 에 붙여야 발행가능.

Directory : 작업디렉토리 (실제파일로 구성)
Index : 준비영역 (staging Area)
Head : 최종 확정본

Head > Repository : 최종 발행 (내꺼 깃 서버에 발행)

Directory > git add .  >  Index                       * git add <파일 이름>
Index >  git commit -m "initial commit" > Head        * git commit -m "이번 확정본에 대한 설명"
Head > git push origin master                         * master : 마스터 브랜치
 * git remote add origin <원격 서버 주소> : 만약 기존의 원격저장소가 아니면 이렇게 해줘야됨.


<nodeJS 로 javascripts 실행>
node console.log("seevalnyun"); 일케 하면된다.

///////////////////////// Server GET 과 POST /////////////////////////////////

server Listen 하면 Localhost:4000 했을 때 인터넷에는
Cannot GET/ 
이렇게 뜨는데, 이 GET 이 중요하다.
보통 웹사이트에 가면, URL 주소로 접속을 하게 되는데 이때 브라우저는 자동적으로 서버의 GET 메소드를 실행한다. 
>> 자동으로 서버에 유저대신해서 요청을 해주는 것이다. 
>> 서버는 이에대해 응답해야함. HTML 페이지든 뭐든간에.
기본적으로 이렇게 해서 유저는 웹페이지를 읽어오게 됨. 

그리고 웹사이트에 접속해서 로그인을 하면 브라우저는 서버의 POST 메소드를 실행하게 된다. 
브라우저가 웹사이트 정보를 서버로 전달하는 것이다. 

이게 http, 브라우저, 웹페이지의 작동방식이다.

그니까 현재의 GET request로는 웹페이지의 정보를 서버로 전달할수가 없다.

////////////////////////// Babel ////////////////////////////////
이처럼 Babel는 최신 사양의 자바스크립트 코드를 IE나 구형 브라우저에서도 동작하는 ES5 이하의 코드로 변환(트랜스파일링)할 수 있다. Babel을 사용하기 위한 개발 환경을 구축해 보자.
(IE와 다른 구형 브라우저에서는 자바스크립트의 최신 기능을 지원하지 않을 수 있다. Babel을 사용하면 위 코드를 아래와 같이 ES5 이하의 버전으로 변환할 수 있다.)

Babel 은 기본적으로 최신의 js 코드를 구버전의 js 코드로 바꿔서 보여주는 사이트 인데
우리는 이 Babel을 여기서 써볼꺼다. 

npm install @babel/node

를 조져보자.
여튼 내생각엔 브라우저에서 어느정도의 버전의 js 를 쓸것인지 만들어주는 역할? 인것 같다. 시발 노마드 개새끼 설명 개대추앟네 시벌놈이

env 버전은 가장 최신이긴 한데 실험적인 수준은 아닌 수준이라고 한다. 쓰고싶은대로 JS 코드를 써도되는데 실험적인 수준까지는 아닌것. 

npm install --save-dev @babel/preset-env

 이걸 조져서 프로젝트에 설치해주고 


.babelrc 를 만들어 준다음에 Json 복사해서 붙여넣기 해줌.
 
이렇게 하면 최신 JS 버전의 코드를 사용할 수 있다. (import 를 사용했다.)

"start": "babel-node index.js" 그런다음 package json 에서 node index.js 를 이렇게 바꾸면
babel 이 자동으로 실행되어 최신의 js 코드를 구버전으로 자동으로 바꾸어줘서 브라우저가 실행할 수 있게 만든다.

/////////////////////// ES 6 란 ///////////////////////////////////

JS (java scripts)  : 자바스크립트(Javascript)는 1995년 넷스케이프(Netscape) 웹 브라우져에서 웹페이지에 동적인 요소를 구현하기 위해서 발명 되었다. 그 후 많은 다른 웹 브라우져들 또한 이 언어를 탑재하기 시작했고, 그 결과로 현대의 웹 어플리케이션의 구현을 가능하게 만든 언어이다.

ES (ECMA Scripts) : 자바스크립트(Javascript)가 넷스케이프(Netscape) 브라우져만이 아니라 다른 웹 브라우져들의 지원까지 받기 시작하면서
 다양한 웹 브라우져에서 자바스크립트(Javascript)가 공통되게 잘 작동하기 위해서 표준 규격이 필요해졌는데,
  이 때문에, ECMA 국제 기구에서 “ECMAScript Standard”라 불리는 스크립트 표준이 만들어지게 된다. 자바스크립트와 비슷한 뜻으로 많이 들어본 사람들이 있을텐데, 
  Javascript는 ECMAScript와 BOM(Browser Object Model) 와 DOM(Document Object Model)이라는 1개의 코어와, 2개의 모델로 이루어져 있다.
   ECMAScript 와 Javascript 는 비슷한 뜻으로 자주 쓰이나 작은 차이를 가지고 있다는 걸 알아두자.


ECMAScript를 ES라 줄여 부르고 버전에 따라서 ES뒤에 숫자가 붙는데 아직까지도 가장 많이 쓰이는 ES5는 
2009년에 만들어졌고 ES6은 2015년에 만들어져 널리 사용중이다.
현재 대부분의 자바스크립트의 기준은 ES5로 이루어져있지만
 ES6에서 새로운 기술들이 도입되면서 보다 효율적인 코드작성을 위해 개발자들은 공부를 하고있다.

/////////////////////// nodemon 과 프로젝트와 상관없는 패키지 설치하는법 /////////////////////////////////////////////

일단 지금 컴파일 조질때마다 서버 껏다 켯다 하는게 존나 좆같으므로, 
nodemon 이라는 것을 설치할 례정인데, 그전에

어떻게 하면, 프로젝트와 상관없는 (dependencies 에 없는) 패키지를 설치할 수 있는가 이다. 
개발자에게 도움이 될만한 더 편하게 해줄 패키지를 설치할 례정이라 이말이야

npm install nodemon -D 이렇게 하면된다. 

그라믄 
devDependencies 이런게 생기는데, 이건 내가 필요한게 된다.

그다음에 

    "start": "nodemon --exec babel-node index.js" 이렇게 바꾸자 scripts 를.

    그러면 저장할때마다 서버 재시작 됨. 개씹지리는 모스비구요

///////////////////////////////// Middle Ware ///////////////////////////////////

Epxress 에서 Middle ware 는 처리가 끝날 때까지 연결되어 있는 어떤 것 (?) ... 시벌?
우선 어떻게 연결이 시작되는가? 이다, 어떻게 request 가 시작되는지..

시작은 브라우저부터이다. 

User 가 웹사이트에 접속하려고 할 때, 브라우저는 index.js 를 실행하려 할테고, 
app 객체 (express()) 는 home route ("/") 가 존재하는지 살펴보게 된다. 그 다음 home 에 연결된 handleHome 메소드를 그다음에 실행한다.
handleHome 은 그다음에 app 가 건네준 respond object 를 통해서  "hello 시발놈아" 를 응답한다.

하지만 보통 연결은 그 흐름이 그렇게 간단하게 되지 않는다. 
유저와 마지막 응답사이에 중간과정이 있게된다. (복잡한 웹사이트들에는 있나봄. 지금 좆밥코스라서 감이안오는 것이라 생각함.)
이게 바로 middle ware 다.
///
그렇게 해서 만들어 보았다 (간단히 get 함수에 핸들러 두개를 두면 된다.)
근데 중요한 것은, middleware 에게 request 가 왔을 때 , 그 request를 가지고 respond를 할 권한을 줘야 한다는 것이다. 


express의 모든 route와 그를 처리하는 handler들은 기본적으로 3개의 object를 app 로부터 건네 받는데, next라는 것이 있다. 
단지 마지막으로 respond를 하는 handler 들에는 next를 쓰지 않는다. 

 next(); 를 미들웨어에서 하면 다음으로 진행된다.

middleware 는 양파라고 생각하면 됨, 최종 respond 까지 여러겹의 layer 가 있는 것이고, middleware 가 그 layer 이다.
양파의 중심에 있는 최종함수가 user 에게 무엇인가를 return 하는 것이다. 
물론 반환할게 없거나 (최종함수) , 미들웨어함수가 next() 를 안해주면 계속 로딩으로 뜰것임.

미들웨어는 내가 원하는만큼 가질 수 가 있다. 왜그렇게 하냐, 그게 존나 날 편하게 해주기 때문이다. 
예를들어 미들웨어는 유저의 로그인여부를 체크하기도 하고, 파일 전송중간에 가로채기도 하며, (딴데로 업로드)
로그를 작성하기도 한다.

또한 아래를 유념하자.

const betweenTest = (req, res, next) => {
  console.log("I only tested before profile.");
  next();
};

//app.get("/", betweenHome, handleHome); // "/" 는 home url 주소. , 브라우저가 get 함수를 실행했으므로 (user 요청) 응답해야됨.
// betweenHome 은 request 와 respond 사이에 껴있음. 오직 "/" route 에만 작용.

app.use(betweenHome); // 이렇게 하면, 모든 웹사이트 응답에 사이에 끼게 됨.
// 여기서 순서가 중요한데 get 에서 route 를 찾기전에 이 middle ware 들이 실행되는 것이다.
// request 가 와서 app 는 "/" 와 "/profile" route 를 찾기 전에 betweenHome 미들웨어를 무조건 실행하게 된다. 이게 더 뒤로 가거나 하면 안됨
// 그리고 route 전에는 원하는 만큼의 middleware를 써도된다.

app.get("/", handleHome);

app.use(betweenTest); // 이새끼는 home 응답에서는 안되고 /profile 찾을때만 수행이 되는 미들웨어임.

app.get("/profile", handleProfile); // "/profile" 이렇게 route 가 생성 (단순히 객체가 생성된다고 생각하면 될듯) 되고 handler 와 묶임.

app.listen(PORT, handleListening); // port Number Listen...
